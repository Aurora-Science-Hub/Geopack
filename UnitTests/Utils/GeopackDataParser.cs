using AuroraScienceHub.Geopack.UnitTests.Geopack2008.TestData;
using AuroraScienceHub.Geopack.UnitTests.Models;

namespace AuroraScienceHub.Geopack.UnitTests.Utils;

public static class GeopackDataParser
{
    /// <summary>
    /// Common input (parametrization) data for Geopack2008
    /// </summary>
    /// <param name="rawData"></param>
    /// <returns></returns>
    public static InputGeopackData ParseInputData(this string rawData)
    {
        var lines = rawData.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);
        var result = new InputGeopackData();
        var lineIndex = 0;

        // Parse header
        var headerParts = lines[lineIndex++].Split(new[] { ' ', '=', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        var year = int.Parse(headerParts[1]);
        var doy = int.Parse(headerParts[3]);
        var hour = int.Parse(headerParts[5]);
        var minute = int.Parse(headerParts[7]);
        result.DateTime = new DateTime(year, 1, 1, hour, minute, 0).AddDays(doy - 1);

        // Parse solar wind pressure
        var solarWindParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.VGSEX = double.Parse(solarWindParts[3]);
        result.VGSEY = double.Parse(solarWindParts[4]);
        result.VGSEZ = double.Parse(solarWindParts[5]);

        return result;
    }

    /// <summary>
    /// Parse test data for Trace and full flow generated by Tsyganenko's example code
    /// </summary>
    /// <param name="data"> Test data </param>
    public static GeopackCommons ParseRecalcCommons(string data)
    {
        var lines = data.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var result = new GeopackCommons();
        var lineIndex = 0;

        // Parse Common1 coefficients
        var common1string = lines[lineIndex++].Split(new[] { ' ', '=' }, StringSplitOptions.RemoveEmptyEntries);
        result.ST0 = double.Parse(common1string[2]);
        result.CT0 = double.Parse(common1string[3]);
        result.SL0 = double.Parse(common1string[4]);
        result.CL0 = double.Parse(common1string[5]);
        result.CTCL = double.Parse(common1string[6]);
        result.STCL = double.Parse(common1string[7]);
        result.CTSL = double.Parse(common1string[8]);
        result.STSL = double.Parse(common1string[9]);
        result.SFI = double.Parse(common1string[10]);
        result.CFI = double.Parse(common1string[11]);
        result.SPS = double.Parse(common1string[12]);
        result.CPS = double.Parse(common1string[13]);
        result.DS3 = double.Parse(common1string[14]);
        result.CGST = double.Parse(common1string[15]);
        result.SGST = double.Parse(common1string[16]);
        result.PSI = double.Parse(common1string[17]);
        result.A11 = double.Parse(common1string[18]);
        result.A21 = double.Parse(common1string[19]);
        result.A31 = double.Parse(common1string[20]);
        result.A12 = double.Parse(common1string[21]);
        result.A22 = double.Parse(common1string[22]);
        result.A32 = double.Parse(common1string[23]);
        result.A13 = double.Parse(common1string[24]);
        result.A23 = double.Parse(common1string[25]);
        result.A33 = double.Parse(common1string[26]);
        result.E11 = double.Parse(common1string[27]);
        result.E21 = double.Parse(common1string[28]);
        result.E31 = double.Parse(common1string[29]);
        result.E12 = double.Parse(common1string[30]);
        result.E22 = double.Parse(common1string[31]);
        result.E32 = double.Parse(common1string[32]);
        result.E13 = double.Parse(common1string[33]);
        result.E23 = double.Parse(common1string[34]);
        result.E33 = double.Parse(common1string[35]);

        // Parse coordinates
        while (lineIndex < lines.Length)
        {
            var ghrec = lines[lineIndex++].Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (ghrec.Length != 3)
            {
                continue;
            }

            result.G?.Add(double.Parse(ghrec[0]));
            result.H?.Add(double.Parse(ghrec[1]));
            result.REC?.Add(double.Parse(ghrec[2]));
        }

        return result;
    }

    /// <summary>
    /// Parse test data for Trace and full flow generated by Tsyganenko's example code
    /// </summary>
    /// <param name="data"> Test data </param>
    public static GeopackCommons ParseTrace(string data)
    {
        var lines = data.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var result = new AuroraScienceHub.Geopack.UnitTests.Geopack2008.TestData.GeopackCommons();
        var lineIndex = 0;

        // Parse header
        var headerParts = lines[lineIndex++].Split(new[] { ' ', '=', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        var year = int.Parse(headerParts[1]);
        var doy = int.Parse(headerParts[3]);
        var hour = int.Parse(headerParts[5]);
        var minute = int.Parse(headerParts[7]);
        result.DateTime = new DateTime(year, 1, 1, hour, minute, 0).AddDays(doy - 1);

        // Parse solar wind pressure
        var solarWindParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.SolarWindPressure = double.Parse(solarWindParts[5]);

        // Parse DST index
        var dstParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.DstIndex = double.Parse(dstParts[1]);

        // Parse IMF By and Bz
        var imfParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.ByIMF = double.Parse(imfParts[4]);
        result.BzIMF = double.Parse(imfParts[5]);

        // Skip the line "THE LINE IN GSW COORDS:"
        lineIndex++;

        // Parse coordinates
        while (lineIndex < lines.Length)
        {
            var coordParts = lines[lineIndex++].Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (coordParts.Length != 3)
            {
                continue;
            }

            var x = double.Parse(coordParts[0]);
            var y = double.Parse(coordParts[1]);
            var z = double.Parse(coordParts[2]);
            result.FieldLineCoordinates?.Add((x, y, z));
        }

        return result;
    }
}
