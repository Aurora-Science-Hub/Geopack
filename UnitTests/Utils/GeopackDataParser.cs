using System.Globalization;
using AuroraScienceHub.Geopack.UnitTests.Geopack2008.TestData;
using AuroraScienceHub.Geopack.UnitTests.Models;

namespace AuroraScienceHub.Geopack.UnitTests.Utils;

public static class GeopackDataParser
{
    /// <summary>
    /// Common input (parametrization) data for Geopack2008
    /// </summary>
    /// <param name="rawData"></param>
    /// <returns></returns>
    public static InputGeopackData ParseInputData(this string rawData)
    {
        var lines = rawData.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);
        var result = new InputGeopackData();
        var lineIndex = 0;

        // Parse header
        var headerParts = lines[lineIndex++].Split(new[] { ' ', '=', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        var year = headerParts[1].ParseInt();
        var doy = headerParts[3].ParseInt();
        var hour = headerParts[5].ParseInt();
        var minute = headerParts[7].ParseInt();
        result.DateTime = new DateTime(year, 1, 1, hour, minute, 0).AddDays(doy - 1);

        // Parse solar wind pressure
        var solarWindParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.VGSEX = solarWindParts[3].ParseDouble();
        result.VGSEY = solarWindParts[4].ParseDouble();
        result.VGSEZ = solarWindParts[5].ParseDouble();

        return result;
    }

    /// <summary>
    /// Parse test data for Trace and full flow generated by Tsyganenko's example code
    /// </summary>
    /// <param name="data"> Test data </param>
    public static GeopackCommons ParseRecalcCommons(string data)
    {
        var lines = data.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var result = new GeopackCommons();
        var lineIndex = 0;

        // Parse Common1 coefficients
        var common1string = lines[lineIndex++].Split(new[] { ' ', '=' }, StringSplitOptions.RemoveEmptyEntries);
        result.ST0 = common1string[2].ParseDouble();
        result.CT0 = common1string[3].ParseDouble();
        result.SL0 = common1string[4].ParseDouble();
        result.CL0 = common1string[5].ParseDouble();
        result.CTCL = common1string[6].ParseDouble();
        result.STCL = common1string[7].ParseDouble();
        result.CTSL = common1string[8].ParseDouble();
        result.STSL = common1string[9].ParseDouble();
        result.SFI = common1string[10].ParseDouble();
        result.CFI = common1string[11].ParseDouble();
        result.SPS = common1string[12].ParseDouble();
        result.CPS = common1string[13].ParseDouble();
        result.DS3 = common1string[14].ParseDouble();
        result.CGST = common1string[15].ParseDouble();
        result.SGST = common1string[16].ParseDouble();
        result.PSI = common1string[17].ParseDouble();
        result.A11 = common1string[18].ParseDouble();
        result.A21 = common1string[19].ParseDouble();
        result.A31 = common1string[20].ParseDouble();
        result.A12 = common1string[21].ParseDouble();
        result.A22 = common1string[22].ParseDouble();
        result.A32 = common1string[23].ParseDouble();
        result.A13 = common1string[24].ParseDouble();
        result.A23 = common1string[25].ParseDouble();
        result.A33 = common1string[26].ParseDouble();
        result.E11 = common1string[27].ParseDouble();
        result.E21 = common1string[28].ParseDouble();
        result.E31 = common1string[29].ParseDouble();
        result.E12 = common1string[30].ParseDouble();
        result.E22 = common1string[31].ParseDouble();
        result.E32 = common1string[32].ParseDouble();
        result.E13 = common1string[33].ParseDouble();
        result.E23 = common1string[34].ParseDouble();
        result.E33 = common1string[35].ParseDouble();

        // Parse coordinates
        while (lineIndex < lines.Length)
        {
            var ghrec = lines[lineIndex++].Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (ghrec.Length != 3)
            {
                continue;
            }

            result.G?.Add(ghrec[0].ParseDouble());
            result.H?.Add(ghrec[1].ParseDouble());
            result.REC?.Add(ghrec[2].ParseDouble());
        }

        return result;
    }

    /// <summary>
    /// Parse test data for Trace and full flow generated by Tsyganenko's example code
    /// </summary>
    /// <param name="data"> Test data </param>
    public static GeopackCommons ParseTrace(string data)
    {
        var lines = data.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var result = new AuroraScienceHub.Geopack.UnitTests.Geopack2008.TestData.GeopackCommons();
        var lineIndex = 0;

        // Parse header
        var headerParts = lines[lineIndex++].Split(new[] { ' ', '=', '\t' }, StringSplitOptions.RemoveEmptyEntries);
        var year = headerParts[1].ParseInt();
        var doy = headerParts[3].ParseInt();
        var hour = headerParts[5].ParseInt();
        var minute = headerParts[7].ParseInt();
        result.DateTime = new DateTime(year, 1, 1, hour, minute, 0).AddDays(doy - 1);

        // Parse solar wind pressure
        var solarWindParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.SolarWindPressure = solarWindParts[5].ParseDouble();

        // Parse DST index
        var dstParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.DstIndex = dstParts[1].ParseDouble();

        // Parse IMF By and Bz
        var imfParts = lines[lineIndex++].Split(new[] { ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
        result.ByIMF = imfParts[4].ParseDouble();
        result.BzIMF = imfParts[5].ParseDouble();

        // Skip the line "THE LINE IN GSW COORDS:"
        lineIndex++;

        // Parse coordinates
        while (lineIndex < lines.Length)
        {
            var coordParts = lines[lineIndex++].Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (coordParts.Length != 3)
            {
                continue;
            }

            var x = coordParts[0].ParseDouble();
            var y = coordParts[1].ParseDouble();
            var z = coordParts[2].ParseDouble();
            result.FieldLineCoordinates?.Add((x, y, z));
        }

        return result;
    }

    /// <summary>
    /// Just a helper for readiness of the code
    /// </summary>
    /// <param name="value"></param>
    internal static double ParseDouble(this string value) => double.Parse(value, CultureInfo.InvariantCulture);

    /// <summary>
    /// Just a helper for readiness of the code
    /// </summary>
    /// <param name="value"></param>
    internal static int ParseInt(this string value) => int.Parse(value);

    /// <summary>
    /// Splits line with parameters,
    /// when parameters are separated by space, equal sign or tab
    /// </summary>
    internal static string[] SplitParametersLine(this string line)
        => line.Split([' ', '=', '\t'], StringSplitOptions.RemoveEmptyEntries);
}
